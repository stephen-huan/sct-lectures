\documentclass[11pt, oneside]{article}
\usepackage{titling, hyperref, geometry, amsmath, amssymb, algorithm, graphicx, textcomp, subcaption}
\usepackage[noend]{algpseudocode}
\usepackage[cache=false]{minted}
\geometry{a4paper}

\hypersetup{
  colorlinks=true,
  urlcolor=cyan
}

\newcommand{\emphasis}[1]{\textcolor{blue}{\textbf{\textit{#1}}}}

\title{Monotonic Queue}
\author{Stephen Huan}

\begin{document}
\maketitle

\section{Definition}

A \emphasis{Monotonic queue} is a queue with \( O(1) \) inserts and pops on both sides, but with the additional property
that it can compute the minimum element in the queue in \( O(1) \).

\section{Implementation}
\subsection{Min Stack}

Consider a min stack first. Since a stack is first in last out, we only need to propagate a minimum element
``upwards'' in the stack, that is, for elements that are added after it.
Have each number in the stack be represented by a tuple of (value, minvalue). Maintain the min value as follows:
For an empty stack, adding a new value will make the new value the minimum value, since it's the only element in the stack, so add the tuple (value, value).
Otherwise, compare the new value with the current minimum (check the 2nd number in the tuple at the top of the stack) and
make the smaller of the two the minimum value. When removing elements, just pop as normal.

Thus, at any given moment the stack can access the minimum element at the top of the stack in constant time,
and still maintain constant time addition and removal.

\begin{minted}{python}
class MinStack:

    def __init__(self, f=min): self.stk, self.f = [], f

    def empty(self): return len(self.stk) == 0

    def append(self, val):
      self.stk.append((val, \
      self.f(val, self.stk[-1][1]) if not self.empty() else val))

    def pop(self): return self.stk.pop()[0]

    def min(self): return self.stk[-1][1]
\end{minted}

\subsection{Min Queue}
Now, simulate a queue using two stacks. Intuitively, a stack will ``reverse'' elements while a queue will keep them in the same order.
For example, adding the elements 1, 2, 3 to a stack then popping off will yield 3, 2, 1 but a queue will give 1, 2, 3.

Thus, using two stacks reverses the reverse, which gives the original order.
Designate one stack as the ``in stack'' and the other as the ``out stack''.
When adding elements, add them to the in stack.
When removing elements, check whether the out stack is empty or not.
If the out stack is empty, pop off everything in the in stack into the out stack.
Otherwise, pop off an element from the out stack. By only popping off elements
from the in stack to the out stack if the out stack is empty, that guarantees
continuity in the reversal. Take the following sequence of pushes and pops:

add 1, add 2, pop, add 3, pop, pop.

After the first two additions the in stack contains [1, 2] while the out stack is empty.
Then, on the pop, the in stack empties into the out stack yielding [] and [2, 1].
The out stack is popped to give a value, resulting in [] and [2]. 3 is added to the in stack,
yielding [3], [2] and on the next pop, the out stack is emptied. Finally, on the last pop,
the in stack again empties into the outstack which then pops the top element off.

If we use two min stacks to implement a queue, then the minimum element in the queue is
just the minimum element in either stack. Since we can access the minimum element in a stack
in \( O(1) \), we can find the minimum of the queue in \( O(1) \).
We still have constant time addition to the queue since we just add it to the in stack,
and to analyze the work done in popping an element off, each element is processed at
most two times (entering the in stack and exiting into the out stack). Thus, the
amoritized work in popping is \( O(n) \) (if the out stack is empty, it will do \( O(n) \) work
for a single pop but then \( O(1) \) work for the next \( n \) pops).

\begin{minted}{python}
class MinQueue:

    def __init__(self, f=min):
      self.instk, self.outstk, self.f = MinStack(f), MinStack(f), f

    def enque(self, val): self.instk.append(val)

    def deque(self):
        if self.outstk.empty():
            while not self.instk.empty(): self.outstk.append(self.instk.pop())
        return self.outstk.pop()

    def min(self):
        if not self.instk.empty() and not self.outstk.empty():
            return self.f(self.instk.min(), self.outstk.min())
        elif self.instk.empty(): return self.outstk.min()
        elif self.outstk.empty(): return self.instk.min()
\end{minted}

\section{Past Lectures}

\begin{enumerate}
  \item \href{https://activities.tjhsst.edu/sct/lectures/1819/2019_1_8_Monotonic_Queues_and_USACO_Review.pdf}{``Monotonic Queues and USACO Review'' (Daniel Wisdom, 2019)}
\end{enumerate}

\section{Works Cited}

\begin{enumerate}
  \item Richard Zhan
\end{enumerate}

\end{document}
